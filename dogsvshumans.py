# -*- coding: utf-8 -*-
"""DogsvsHumans.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A8AqzNWW-IdCH3WF140dBynbqno4Jsvr
"""

# !wget --no-check-certificate https://storage.googleapis.com/mledu-datasets/cats_and_dogs_filtered.zip

import zipfile

# Unzip the archive
local_zip = './cats_and_dogs_filtered.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall()

zip_ref.close()

import os

base_dir = "cats_and_dogs_filtered"

train_path = os.path.join(base_dir,"train")
val_path = os.path.join(base_dir,"validation")

# print(os.listdir(train_path))

# Getting the images labelled using ImageGenerator from keras

from tensorflow.keras.preprocessing.image import ImageDataGenerator

img_gen = ImageDataGenerator(rescale = 1/255)

train_data = img_gen.flow_from_directory(train_path, batch_size=20, class_mode="binary", target_size=(150,150))
val_data = img_gen.flow_from_directory(val_path, batch_size=20, class_mode="binary", target_size=(150,150))

# Defining the model to classify our images
from tensorflow import keras

model = keras.models.Sequential([
                      keras.layers.Conv2D(64, (3,3), input_shape=(150,150,3), activation="relu"),
                      keras.layers.MaxPooling2D(2,2),
                      keras.layers.Conv2D(32, (3,3), activation="relu"),
                      keras.layers.MaxPooling2D(2,2),
                      keras.layers.Conv2D(32, (3,3), activation="relu"),
                      keras.layers.MaxPooling2D(2,2),
                      keras.layers.Conv2D(16, (3,3), activation="relu"),
                      keras.layers.MaxPooling2D(2,2),
                      keras.layers.Conv2D(16, (3,3), activation="relu"),
                      keras.layers.MaxPooling2D(2,2),

                      keras.layers.Flatten(),
                      keras.layers.Dense(512, activation='relu'),
                      keras.layers.Dense(1, activation='sigmoid')
])

# model.summary()

from tensorflow.keras.optimizers import RMSprop

model.compile(optimizer=RMSprop(learning_rate=0.001), loss="binary_crossentropy", metrics=['accuracy'])

history = model.fit(train_data,
          epochs=12,
          steps_per_epoch=100,
          validation_data=val_data,
          validation_steps=50,
          verbose=2
          )

model.evaluate(val_data)

# for elem in val_data:
#   print(elem)
#   break

